Analysis:

// read partial data (counts)
val loaded = sc.textFile("/scratch/users/pernek/results/comb_counts_txt1_3f*")

// split lines into tupples ("CSV list of topics", occurence count)
val merged = loaded.map(m => m.split("\t")).map(m => (m.slice(1, m.size).mkString("\t"), m(0).toInt))

// reduce partial results from all months to one file
val joined = merged.reduceByKey(_+_)

// cache joined results
val cached = joined.cache

// order cached results by occurence count decreasing
val ordered = cached.map{case(key, count) => (count, key)}.sortByKey(false).cache

// filter out rows that don't fit the constraints
// This query only takes into account sequences with 3 items, and counts with 2 drug interactions and
// one not drug interaction, where the drug interaction are not identical
val partial = obj.filter{case(count, topics) => topics.size == 3 && (!topics(1).toLowerCase.contains("drug information") && topics(0).toLowerCase.contains("drug information") && topics(2).toLowerCase.contains("drug information") && topics(0) != topics(2)) || (!topics(0).toLowerCase.contains("drug information") && topics(1).toLowerCase.contains("drug information") && topics(2).toLowerCase.contains("drug information") && topics(1) != topics(2)) || (topics(0).toLowerCase.contains("drug information") && topics(1).toLowerCase.contains("drug information") && !topics(2).toLowerCase.contains("drug information") && topics(0) != topics(1))}.map(x=>x._1 + "\t" + x._2.mkString(" AND "))

// save filtered rows to the files system (merge everything in 1 file)
partial.coalesce(1).saveAsTextFile("/scratch/users/pernek/results/2drug_treatment1")
